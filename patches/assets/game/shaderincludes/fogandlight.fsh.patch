--- a/assets/game/shaderincludes/fogandlight.fsh
+++ b/assets/game/shaderincludes/fogandlight.fsh
@@ -1,11 +1,16 @@
-uniform float flatFogDensity;
+ï»¿uniform float flatFogDensity;
 uniform float flatFogStart;
 uniform float viewDistance;
 uniform float viewDistanceLod0;
 uniform float zNear = 0.3;
 uniform float zFar = 1500.0;
-uniform vec3 lightPosition;
 uniform float shadowIntensity = 1;
+uniform vec3 lightPosition;
+
+#if GODRAYS > 0
+in vec4 shadowRayStart;
+in vec4 shadowLightPos;
+#endif
 
 #if SHADOWQUALITY > 0
 in float blockBrightness;
@@ -20,6 +25,7 @@
 uniform sampler2DShadow shadowMapNear;
 #endif
 
+#define VOLUMETRIC_SSAO_DECLINE 0.5f
 
 float linearDepth(float depthSample)
 {
@@ -32,9 +38,9 @@
 	return vec4(mix(rgbaPixel.rgb, rgbaFog.rgb, fogWeight), rgbaPixel.a);
 }
 
-
 float getBrightnessFromShadowMap() {
 	#if SHADOWQUALITY > 0
+
 	float totalFar = 0.0;
 	if (shadowCoordsFar.z < 0.999 && shadowCoordsFar.w > 0) {
 		for (int x = -1; x <= 1; x++) {
@@ -44,7 +50,8 @@
 			}
 		}
 	}
-	totalFar /= 9.0;
+
+	totalFar /= 9.0f;
 
 	
 	float b = 1.0 - shadowIntensity * totalFar * shadowCoordsFar.w * 0.5;
@@ -62,9 +69,7 @@
 		}
 	}
 	
-	totalNear /= 9.0;
-	
-	
+	totalNear /= 9.0f;
 
 	
 	b -=  shadowIntensity * totalNear * shadowCoordsNear.w * 0.5;
@@ -86,7 +91,7 @@
 	
 	// Let's also define that diffuse light from the sky provides an additional brightness boost for up facing stuff
 	// because the top side of blocks being darker than the sides is uncanny o__O
-	nb = max(nb, dot(normalize(normal), vec3(0, 1, 0)) * 0.95);
+	nb = max(nb, dot(normalize(normal), vec3(0, 1, 0)) * 0.6);
 	
 	return mix(1, nb, normalShadeIntensity);
 }
@@ -96,24 +101,22 @@
 vec4 applyFogAndShadow(vec4 rgbaPixel, float fogWeight) {
 	float b = getBrightnessFromShadowMap();
 	rgbaPixel *= vec4(b, b, b, 1);
-	
-	return applyFog(rgbaPixel, fogWeight);
+
+	return applyFog(rgbaPixel, fogWeight*1);
 }
 
 vec4 applyFogAndShadowWithNormal(vec4 rgbaPixel, float fogWeight, vec3 normal, float normalShadeIntensity, float minNormalShade) {
 	float b = getBrightnessFromShadowMap();
 	float nb = getBrightnessFromNormal(normal, normalShadeIntensity, minNormalShade);
-		
+	
 	b = min(b, nb);
 	rgbaPixel *= vec4(b, b, b, 1);
 	
-	return applyFog(rgbaPixel, fogWeight);
+	return applyFog(rgbaPixel, fogWeight*1);
 }
 
-
-
 float getFogLevel(float fogMin, float fogDensity, float worldPosY) {
-	float depth = gl_FragCoord.z;	
+	float depth = gl_FragCoord.z;
 	float clampedDepth = min(250, depth);
 	float heightDiff = worldPosY - flatFogStart;
 	
@@ -133,4 +136,33 @@
 	val += fogMin; 
 	
 	return clamp(val, 0, 1);
+}
+
+float calculateVolumetricScatter(vec3 position) {
+#if GODRAYS > 0
+	float dither = fract(0.75487765 * gl_FragCoord.x + 0.56984026 * gl_FragCoord.y);
+	//float dither = 0;
+
+	int maxSamples = 6;
+	
+	vec3 dV = (shadowCoordsFar.xyz-shadowRayStart.xyz)/maxSamples;
+	//vec4 shadowLightPosition = shadowMatrix * vec4(lightPosition, 1.0);
+	vec3 lightDir = normalize(shadowLightPos.xyz-shadowRayStart.xyz);
+	
+	vec3 progress = shadowRayStart.xyz + dV*dither;
+	
+	float vL = 0.0f;
+	
+	for (int i = 0; i < maxSamples; ++i) {
+		
+		vL += texture(shadowMapFar, vec3(progress.xy, progress.z - 0.0009));
+		progress += dV;
+	}
+	
+	float normalOut = min(1, vL * length(position) / 1000.0f / maxSamples);
+	float intensity = dot(normalize(dV), lightDir);
+	float phase = 2.5+exp(intensity*3.0)/3.0;
+	return min(0.9f, pow(phase * normalOut, VOLUMETRIC_FLATNESS));
+#endif
+	return 0.0f;
 }
\ No newline at end of file
