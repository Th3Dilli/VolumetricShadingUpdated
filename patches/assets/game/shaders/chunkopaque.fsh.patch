--- a/assets/game/shaders/chunkopaque.fsh
+++ b/assets/game/shaders/chunkopaque.fsh
@@ -1,4 +1,4 @@
-#version 330 core
+ï»¿#version 330 core
 #extension GL_ARB_explicit_attrib_location: enable
 
 uniform sampler2D terrainTex;
@@ -39,7 +39,7 @@
 #include skycolor.fsh
 #include colormap.fsh
 
-void main() 
+void main()
 {
 	// When looking through tinted glass you can clearly see the edges where we fade to sky color
 	// Using this discard seems to completely fix that
@@ -47,28 +47,24 @@
 
 	vec4 texColor = texture(terrainTex, uv) * getColorMapping(terrainTexLinear) * rgba;
 	
-	
 	#if SHADOWQUALITY > 0
 	float intensity = 0.34 + (1 - shadowIntensity)/8.0; // this was 0.45, which makes shadow acne visible on blocks
 	#else
 	float intensity = 0.45;
 	#endif
-	
-	outColor = applyFogAndShadowWithNormal(texColor, fogAmount, normal, 1, intensity); 
+
+	outColor = applyOverexposedFogAndShadow(texColor, fogAmount, normal, 1, intensity, vertexPosition, fogDensityIn);
 	
 	float glow = 0;
 	
-	
 	// Fade to sky color
 	float aTest = outColor.a;
-	float godrayLevel = 0;
 	if (rgba.a < 0.999 && haxyFade > 0) {
 		vec4 skyColor = vec4(1);
 		vec4 skyGlow = vec4(1);
 		float sealevelOffsetFactor = 0.25;
 	
-		getSkyColorAt(vec3(vertexPosition.x, vertexPosition.y + 0, vertexPosition.z), sunPosition, sealevelOffsetFactor, clamp(dayLight, 0, 1), horizonFog, skyColor, skyGlow);
-		godrayLevel = skyGlow.g;
+		getSkyColorAt(vec3(vertexPosition.x, vertexPosition.y + 0, vertexPosition.z), sunPosition, sealevelOffsetFactor, clamp(dayLight, 0, 1), horizonFog, skyColor, skyGlow);;
 		outColor.rgb = mix(skyColor.rgb, outColor.rgb, max(1-dayLight, max(0, rgba.a)));
 	}
 	
@@ -96,12 +92,14 @@
 	glow = pow(max(0, dot(normal, lightPosition)), 6) / 8 * shadowIntensity * (1 - fogAmount);
 #endif
 
+	float scatterAmt = calculateVolumetricScatter(vertexPosition);
+
 #if SSAOLEVEL > 0
-	outGPosition = vec4(fragPosition.xyz, fogAmount + glowLevel);
+	outGPosition = vec4(fragPosition.xyz, fogAmount + glowLevel + scatterAmt * VOLUMETRIC_SSAO_DECLINE);
 	outGNormal = gnormal;
 #endif
 
-	//outColor = vec4((normal.x + 0.5) / 2, (normal.y + 0.5)/2, (normal.z+0.5)/2, 1);	
-	outGlow = vec4(glowLevel + glow, godrayLevel, 0, outColor.a);
+	//outColor = vec4((normal.x + 0.5) / 2, (normal.y + 0.5)/2, (normal.z+0.5)/2, 1);
+	outGlow = vec4(glowLevel + glow, scatterAmt, 0, outColor.a);
 	//outColor=vec4(1);
 }
